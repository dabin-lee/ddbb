7/3
[스터디 내용 정리 chapter3 ~ 6]

#### chapter 03. 리터럴과 변수, 상수, 데이터 타입
- 3.4 리터럴이란 -> 중괄호{키:값} 의 모양 / 데이터 그 자체를 뜻 한다.
  - 리터럴은 값을 만드는 방법이다. 자바스크립트는 내가 제공한 리터럴 값을 받아 데이터를 만든다. (변수에 넣는 변하지 않는 데이터를 의미하는 것이다.)
  - 식별자와 리터럴 햇갈리지 않기!
  ```
  let room1 = "conference_room_a";
  ```
    - room1은 변수를 가르키는 식별자이다.
    - "conference_room_a"는 문자열 리터럴인 동시 roo1의 값이다.

> 변수, 상수, 리터럴
> 상수는 변하지 않는 변수 / 메모리 값 변경 할 수 없다. (메모리 위치)
> 리터럴은 변수의 값이 변하지 않는 데이터를 의미 (메모리 위치 안의 값)
>




- 3.5 불리언 공부 필수#! 개념 제대로 알아 두기


- 3.8 특수문자 : 어떤의미인지 정도는 파악해둬야함 ( 템플릿스트링을 사용하기엔 최근에 사용빈도수가 적어짐)
- 3.8.2 여러 줄 문자열 알아두기
- 3.11 null과 undefined 필수
  - null : 프로그래머에게 허용된 데이터 타입
  - undefined : js자체에서 사용하는 것
- 3.19.3 Boolean으로 변환 - 참같은 값, 거짓 같은 참

- 정규식을 쓰는 이유?
  - input숫자에 영어만 넣고 싶다던가 img태그 alt값이 전부 없었는데 한번에 생성가능
  - 정규식을 알면 편해진다.

- 논리연산자 -> 단축평가 알아두기
 - 논리연산자 예시
```
const dog = {
    name:'해피'
};

const getName = (animal) => {
    if(animal){
        return animal.name;
    }
    return undefined;
};

const name = getName(); // 이름이 아직 없는 경우
console.log(name);  // undefined
```
- 논리 연산자 '&&'을 사용하면, 위의 함수 블럭 안의 내용을 더 간단하게 만들 수 있다.
```
const getName = (animal) => {
  return animal && animal.name;
};
```
- 인자 animal에 값이 있을 경우에는 true이므로, animal.name에 해당하는 값을 반환한다.
- 인자 animal에 값이 없을 경우에는 false이므로, '&&' 뒤의 값을 볼 필요도 없이, undefined를 반환한다.

#### chapter 04. 제어문
- tip  : while문을 for문으로 변환 한다던가 여러 작업물들을 참조해서 볼것 -> 각 패턴의 차이점을 보면서 해석을 해보고 개념을 확인
- while문 보다 if 문 과 swich문의 사용이 더 높고 편함
- 4.1.2 (p112) 블럭문을 직접 머리속에 그리고 구현해보기


배열을 수정하지 않고 스프레드 객체 해체 할당
push, shift, < map , reduce, filter 잘 알아두기


#### chapter 05. 표현식과 연산자
  - 구조 분해 할당 구문은 배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식입니다.
- 표현식의 호출은 괄호를 갖고
- 참조는 가지고와서 다른곳에 사용하기 위해


#### chapter 06. 함수
- 해체할당 : 함수를 인자로 넣어둔 상태에서 넣어온 데이터가 많다면?


- 함수 객체 프로퍼티 -> 메서드
- 생성자 함수는 추상적인것

- 제이쿼리랑 js에서 사용하는 this는 다름
- this랑 closer 공부할 것
- call, apply, bind에서 this를 많이 사용
- 화살표 표기법 return호추 ㄹ등 이해해보기


##### 기타사항
  - npm 공부
---


















햇갈리는 부분 정리

- 생성자함수
- 객체생성자
- 리터럴
- class
- 매게변수해체 : 174 (객체 비구조화 할당 :객체 구조 분해)
  배열이나 객체의 속성을 해체하여 그 값을 개별 변수에 담을 수 있게 하는 JavaScript 표현식

- 객체 프로퍼티 함수 -> 메서드 : 176
- 함수 표현식 (그 함수가 익명이 될 수 도 있을 뿐이다. ) / 함수 표현식은 식별자에 할당할 수도 있고 즉시 호출 할 수도 있다.




리터럴 객체를 함수로 받기
객체 안에 함수 넣기



    // 2. 객체 (object) 생성(create)
    // var sungjuk = {irum : '이다빈'};  내장객체 {중괄호}: 내가 사용할 객체를 만들어서 씀
    // var sungjuk - [];  배열객체 [대괄호]:



    // var sungjuk = { //리터럴 객체 방식 (반대 new)
    //     irum : 'bin',
    //     kor : 100,
    //     eng : 99,
    //     mat : 70,
    //     edps : 80
    // }; //내장객체


    var myPro = { //리터럴 객체 방식
        irum :  'ann', //속성 : 속성값 ( property : value )
        kor :    44,
        eng :    55,
        mat :    66,
        edps :   7,
        sum:     function(){ //콜백함수()
            return this.kor+this.eng+this.mat+this.edps; //myPro.kor+myPro.eng
            //return : 더해진 결과 값을 내보내주란 의미
        },
        avg:    function(){
            return Math.floor(this.sum()/4);
            //수학객체 M은 대문자 Math.round(반올림) / Math.ceil(자리올림) / Math.floor(자리내림)
        }
    }; //내장객체


    console.log( myPro.sum(), myPro.avg() );
    //객체에 함수가 들어가면 ()을 꼭 넣어줘야한다. 리터럴 객체 방식



### 객체(object)
- 배열과 달리 순서는 없지만 key, value 구조가 있는 자료구조이며 데이터를 보관할 때 많이 사용 - 객체의 본질은 컨테이너
- 데이터를 표현하기 위해서는 Array, Object를 사용한다.
- 변수안에 하나 혹은 여러개의 프로퍼티를 갖고있다.
- 자바스크립트에서는 원시타입(숫자, 불린값, null과 undefined)를 제외한 모든 값이 객체입니다.
- 즉 속성값은 문자열, 숫자, 객체, 함수여도 된다.
- ex) var wrap = { 'ex ample': 'wrap' };
  - 예문의 프로퍼티 안에는 키(key) : 값 혹은 속성명(value)으로 되어 있다.
- ex) var wrap = { body : {height:167, weight : 53}};
  - 객체안에 속성값으로 객체가 들어갈 수도 있다.
- 객체 중에는 함수와 배열이라는 특수한 객체가 있다.


배열 (array)
```
var a = [];
var a = [1,2,3,"hello", null, true, [], [1,2,3], { hi: 1 }];
```
  - 배열 안에는 모든 타입이 다 들어갈 수 있다.
  - 함수도 배열 안에 배열도, 배열 안에 객체도 들어갈 수 있다.
  - 배열 안에 들어간 것들을 요소(item) 이라고 부른다.
  - 객체와의 차이점은 키(key)값이 value만 순서대로 나열되 있다. -  굳이 키가 필요하지 않고 값만 많이 나열하고 싶을 때 배열을 사용
  - 배열은 자동으로 키가 0, 1, 2, 3, ... 순서로 주어진다.
```
var array = new Array();
array[0] = 1;
array[1] = 'Hello';
```
  -  [ ]를 사용하는 게 권장사항이기도 합니다. new를 사용하지 않고 [ ]만 사용해서 만든 배열을 배열 리터럴이라고 부른다.
  -  객체 리터럴 같은 겁니다.




함수 (Function)
## :star: 함수 정의방법 :star:
```
// 1. 함수 선언문으로 정의하는 방법
- function square(x) { return x*x }

// 2. 함수 리터럴로 정의하는 방법 (함수리터럴 방식으로 만들어진 이름없는 함수를 익명함수)
- var square = function(x) { return x*x }

// 3. Function 생성자로 정의 하는방법
- var square = new Function("x", "return x*x");

// 4. 화살표 함수 표현식으로 정의하는 방법
- var square = x => x*x

// 5. 즉시실행함수 - callback함수

```

[함수 선언식]
```
function addOne(x) {
  var y = x + 1;
  return y;
}
```
  - 선언식 방식으로 만들 때에는 끝에 ;를 붙이지 않는다.
  - 함수 선언식과 표현식 방식의 차이로는 선언문의 호이스팅이라는 현상
  - 선언식은 호이스팅의 영향을 받지만, 표현식은 호이스팅에 영향을 받지 않는다. <br>
  (코드를 구현한 위치와 관계없이 자바스크립트의 특징인 호이스팅에 따라 브라우저가 자바스크립트를 해석할 때 맨 위로 끌어 올려진다.)+

1. [함수 표현식]
[함수 표현식]
- (그 함수가 익명이 될 수 도 있을 뿐이다. ) / 함수 표현식은 식별자에 할당할 수도 있고 즉시 호출 할 수도 있다.
- 익명함수, 기명함수 2가지가 존재한다.

2. [익명함수]
- const g = function(){}
- (함수 표현식으로 익명함수를 만들고 그 함수를 변수에 할당했다.)
- 익명함수는 어디든지 쓸 수 있다. 다른 함수나 메서드의 매개변수로 넘길 수도 있고,

```
var addOne = function(x) {
  var y = x + 1;
  return y;
};
```
  - 변수를 선언하고 함수를 대입하는 방식을 함수 표현식이라고 부른다.
  - x를 매개변수라고 하고 영어로는 Parameter라 한다.
  - x값을 받아서 1을 더한 후 바깥으로 내보내라는 의미로 이것을 반환한다고 표현한다.
```
var i = addOne(1);
i; // 2
```
  - 함수의 실행은 매개변수 x에 상응하는 인자를 넣어주면 된다.
  - 이렇게 미리 만들어둔 함수를 실행하는 행위를 호출한다라고 표현한다.
  - 호출을 통해서 반환하는 값을 저장할 변수를 미리 만들고, 변수 i에 addOne함수의 반환 값을 저장합니다.
  - 1을 넣으면 그 1이 매개변수 x로 전달 -> 함수 내부 코드 실행
```
var j = addOne(2);
var k = addOne(100);
```
  - 각각 j와 k의 값은 3, 101이다.
  - 여기서 2와 100은 매개변수라 부르지 않고 인자라고 부른다.
  - 함수 선언 시 괄호 안의 값은 매개변수(parameter), 함수를 호출 할 때의 괄호 안의 값은 인자(Argument)
```
function multiply(x, y) {
  return x * y; // 곱하기 표시(x)가 프로그래밍에서는 *
}
var l = multiply(5, 6); // 30
var m = multiply(10, 0); // 0
```
  - 매게변수가 2개일때 (x, y)
```
var n = function(object){
  return object.a + object.b + object.c + object.d;
};
n({ a:1, b:2, c:3, d:4 }); //10
```
  - 매개변수의 개수는 원하는 대로 만들 있지만, 헷갈릴 가능성이 크기에 매개변수가 많아질 것 같으면 주로 객체를 사용한다.
  - object.keys : Object 에 속한 key를 배열 형태로 가져온다.


**자바스크립트에서는 함수도 하나의 값이다**
```
var a = {
  b: function() {
    return;
  }
};
```
- 객체나 배열의 값으로 함수도 들어갈 수 있다.
- a.b(); 와 같이 하면 함수를 호출, 속성의 값으로 사용되는 함수를 메소드라고 부른다.
```
var mother = function(func){
  func();
};
var children = function(){
  console.log('안녕하세요');
};
mother(children); //안녕하세요
```
- mother함수가 호출할때 인자값으로 children함수를 넣었다. (함수의 반환값이 아닌 함수 자체를 넣은것)
- children함수는 func 매개변수로 전달되어 func();를 통해 호출된다.
- func();가 children();과 같다.
- 즉 함수가 인자값과 매개변수로써 사용 될 수 있다는 얘기이다.


[함수 표현식의 장점]
- 클로저로 사용
- 콜백으로 이용 (다른 함수의 인자로 넘길 수 있음)

재귀함수
```
const sayBye = function func(who){
  if(who){
    alert(`Hello ${who}`);
  }else{
    func('Guest');
  }
}

const welcome = sayBye;
welcome('Ti'); // 결과는 Hello Ti
```
  - 함수 내부에서 재귀 호출이 가능하게 해준다.
  - 외부에서 함수에 접근할 시 문제가 없도록 해준다.
  - 함수 표현식 에서만 사용할 수 있다. 함수 선언문에서는 사용 불가능.